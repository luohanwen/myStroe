<!DOCTYPE html><html><head><meta charset="utf-8"><title>Backbone.js API中文文档 - CSSer</title><link rel="stylesheet" href="http://s0.csser.com/css/csser.css?v0.5.1-3"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><link rel="shortcut icon" type="image/x-icon" href="http://s0.csser.com/favicon.ico"><link rel="alternate" type="application/rss+xml" title="CSSer" href="http://www.csser.com/feed"><script>var VERSION = 'v0.5.1-3', BASE_URL = 'http://www.csser.com',STATIC_URL = 'http://s0.csser.com',S1_URL = 'http://s1.csser.com',DEBUG = 0,CSRF = '4gUBkSCuXzSxjtBLbL8GFpIJ',UID = '',USERNAME = '',DOMAIN = '', AVATAR = '', EMAIL='', SOCKET_PORT = 3000,SKEY = 'DtVDwZgkOIbxIN6txY2PG2do.jm4IykeiSI4LhOrQlW0LLKhtLbUflGCCRwmgL7SRP1o';</script></head><body><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div class="container"><a href="/" title="csser 前端技术社区" class="brand"><img src="http://s0.csser.com/logo.png" width="119" height="20" alt="csser 前端技术社区"></a><div class="nav-collapse"><form id="search" method="get" action="http://www.google.com/search" target="_blank" class="nav-search pull-left"><div class="btn-group input-append"><input type="text" name="q" value="" autocomplete="off" placeholder="搜索" class="search-query span2"><button type="submit" class="btn"><i class="icon-search"></i></button></div><input type="hidden" name="newwindow" value="1"></form><ul class="nav nav-main"><li><a href="/">首页</a></li><li class="pop-tags"><a href="/tag">标签</a><div class="menu"> <div>Loading</div><hr><a href="/tag" title="所有标签"> <i class="icon-tags icon-white"></i> 所有标签 TOP 50</a></div></li><li><a href="/board">贴板</a><div class="menu"><a href="http://www.csser.com/board/4f4e890bd8a591175600001e"> <i class="icon-exclamation-sign icon-white"></i> 什么是贴板？</a></div></li><li><a href="/question">社区</a></li></ul><ul class="nav pull-right"><li><a href="/login">登录</a></li><li><a href="/register">注册</a></li></ul></div></div></div></div><div class="container"><div class="board-show"><style>
div#sidebar {background: #fff; max-height:600px; position: fixed;width: 200px;overflow-y: auto;overflow-x: hidden;padding: 0 0 10px 10px;border-right: 1px solid #ddd;box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 2px #ccc; -moz-box-shadow: 0 0 2px #ccc;}
a.toc_title, a.toc_title:visited {display: block;color: black;font-weight: bold;margin-top: 10px; font-size:14px;}
a.toc_title:hover {text-decoration: underline;}
#sidebar .version {font-size: 10px;font-weight: normal;}
ul.toc_section {font-size: 11px;line-height: 14px;margin: 5px 0 0 0;padding-left: 0px;list-style-type: none;font-family: Lucida Grande;}
.toc_section li {cursor: pointer;margin: 0 0 3px 0;}
.toc_section li a {text-decoration: none;color: black;}
.toc_section li a:hover {text-decoration: underline;}
#container {position: relative; margin: 0px 0 50px 260px; font-size:14px;}
#container p, #container div.container ul {margin: 20px 0;}
#container p.warning {font-size: 12px;line-height: 18px;font-style: italic;}
#container div.container ul {list-style: circle;font-size: 12px;padding-left: 15px;}
#container b.header {font-size: 16px;line-height: 30px;}
#container span.alias {font-size: 14px;font-style: italic;margin-left: 20px;}
</style>
<div id="sidebar" class="interface">

<a class="toc_title" href="#manual/container">
Backbone.js <span class="version">(0.5.3)</span>
</a>

<a class="toc_title" href="#manual/Introduction">
简介
</a>

<a class="toc_title" href="#manual/Events">
事件
</a>
<ul class="toc_section">
<li>– <a href="#manual/Events-bind">bind</a></li>
<li>– <a href="#manual/Events-unbind">unbind</a></li>
<li>– <a href="#manual/Events-trigger">trigger</a></li>
</ul>

<a class="toc_title" href="#manual/Model">
模型
</a>
<ul class="toc_section">
<li>– <a href="#manual/Model-extend">extend</a></li>
<li>– <a href="#manual/Model-constructor">constructor / initialize</a></li>
<li>– <a href="#manual/Model-get">get</a></li>
<li>– <a href="#manual/Model-set">set</a></li>
<li>– <a href="#manual/Model-escape">escape</a></li>
<li>– <a href="#manual/Model-has">has</a></li>
<li>– <a href="#manual/Model-unset">unset</a></li>
<li>– <a href="#manual/Model-clear">clear</a></li>
<li>– <a href="#manual/Model-id">id</a></li>
<li>– <a href="#manual/Model-cid">cid</a></li>
<li>– <a href="#manual/Model-attributes">attributes</a></li>
<li>– <a href="#manual/Model-defaults">defaults</a></li>
<li>- <a href="#manual/Model-toJSON">toJSON</a></li>
<li>– <a href="#manual/Model-fetch">fetch</a></li>
<li>– <a href="#manual/Model-save">save</a></li>
<li>– <a href="#manual/Model-destroy">destroy</a></li>
<li>– <a href="#manual/Model-validate">validate</a></li>
<li>– <a href="#manual/Model-url">url</a></li>
<li>– <a href="#manual/Model-urlRoot">urlRoot</a></li>
<li>– <a href="#manual/Model-parse">parse</a></li>
<li>– <a href="#manual/Model-clone">clone</a></li>
<li>– <a href="#manual/Model-isNew">isNew</a></li>
<li>– <a href="#manual/Model-change">change</a></li>
<li>– <a href="#manual/Model-hasChanged">hasChanged</a></li>
<li>– <a href="#manual/Model-changedAttributes">changedAttributes</a></li>
<li>– <a href="#manual/Model-previous">previous</a></li>
<li>– <a href="#manual/Model-previousAttributes">previousAttributes</a></li>
</ul>

<a class="toc_title" href="#manual/Collection">
集合
</a>
<ul class="toc_section">
<li>– <a href="#manual/Collection-extend">extend</a></li>
<li>– <a href="#manual/Collection-model">model</a></li>
<li>– <a href="#manual/Collection-constructor">constructor / initialize</a></li>
<li>– <a href="#manual/Collection-models">models</a></li>
<li>– <a href="#manual/Collection-toJSON">toJSON</a></li>
<li>– <a href="#manual/Collection-Underscore-Methods"><b>Underscore 方法 (26)</b></a></li>
<li>– <a href="#manual/Collection-add">add</a></li>
<li>– <a href="#manual/Collection-remove">remove</a></li>
<li>– <a href="#manual/Collection-get">get</a></li>
<li>– <a href="#manual/Collection-getByCid">getByCid</a></li>
<li>– <a href="#manual/Collection-at">at</a></li>
<li>– <a href="#manual/Collection-length">length</a></li>
<li>– <a href="#manual/Collection-comparator">comparator</a></li>
<li>– <a href="#manual/Collection-sort">sort</a></li>
<li>– <a href="#manual/Collection-pluck">pluck</a></li>
<li>– <a href="#manual/Collection-url">url</a></li>
<li>– <a href="#manual/Collection-parse">parse</a></li>
<li>– <a href="#manual/Collection-fetch">fetch</a></li>
<li>– <a href="#manual/Collection-reset">reset</a></li>
<li>– <a href="#manual/Collection-create">create</a></li>
</ul>

<a class="toc_title" href="#manual/Router">
路由
</a>
<ul class="toc_section">
<li>– <a href="#manual/Router-extend">extend</a></li>
<li>– <a href="#manual/Router-routes">routes</a></li>
<li>– <a href="#manual/Router-constructor">constructor / initialize</a></li>
<li>– <a href="#manual/Router-route">route</a></li>
<li>– <a href="#manual/Router-navigate">navigate</a></li>
</ul>

<a class="toc_title" href="#manual/History">
历史
</a>
<ul class="toc_section">
<li>– <a href="#manual/History-start">start</a></li>
</ul>

<a class="toc_title" href="#manual/Sync">
同步
</a>
<ul class="toc_section">
<li>– <a href="#manual/Sync">Backbone.sync</a></li>
<li>– <a href="#manual/Sync-emulateHTTP">Backbone.emulateHTTP</a></li>
<li>– <a href="#manual/Sync-emulateJSON">Backbone.emulateJSON</a></li>
</ul>

<a class="toc_title" href="#manual/View">
视图
</a>
<ul class="toc_section">
<li>– <a href="#manual/View-extend">extend</a></li>
<li>– <a href="#manual/View-constructor">constructor / initialize</a></li>
<li>– <a href="#manual/View-el">el</a></li>
<li>– <a href="#manual/View-dollar">$ (jQuery 或 Zepto)</a></li>
<li>– <a href="#manual/View-render">render</a></li>
<li>– <a href="#manual/View-remove">remove</a></li>
<li>– <a href="#manual/View-make">make</a></li>
<li>– <a href="#manual/View-delegateEvents">delegateEvents</a></li>
</ul>

<a class="toc_title" href="#manual/Utility">
工具
</a>
<ul class="toc_section">
<li>– <a href="#manual/Utility-noConflict">noConflict</a></li>
</ul>

</div>

<div class="content" id="container">

<h1> Backbone.js API中文文档 </h1>

<ul>
<li>翻译：一回 </li>
<li>日期：2011-8-16 </li>
<li>反馈：xianlihua$gmail.com [$ -> @] </li>
</ul>

<p>
<img src="http://documentcloud.github.com/backbone/docs/images/backbone.png" alt="Backbone.js" />
</p>

<p>简单术语翻译对照：<br />散列表（hash） 模型（model） 视图（view） 集合（collection） 回调函数（callback） 绑定（bind）</p>

<p>
    <a href="http://github.com/documentcloud/backbone/" target="_blank">Backbone</a>
为复杂Javascript应用程序提供<b>模型</b>(models)、<b>集合</b>(collections)、<b>视图</b>(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；
  视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。
  </p>
  
  <p>
    Backbone项目 <a href="http://github.com/documentcloud/backbone/" target="_blank">托管在Github</a>
  </p>
  
  <p>
    <i>
      Backbone是 <a href="http://documentcloud.org/" target="_blank">DocumentCloud</a> 的一个开源组件.
    </i>
  </p>
  
  <h2 id="downloads"> 下载和依赖 </h2>
  
  <p>
  <a href="http://www.csser.com" target="_blank">一回</a> 翻译的为 0.5.3 版本，下载请前往 <a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone官网</a> 。
</p>
<p>
  Backbone.js 唯一重度依赖
    <a href="http://documentcloud.github.com/underscore/" target="_blank">Underscore.js</a>.
  对于 RESTful , history 的支持依赖于 <a href="#Router">Backbone.Router</a> ,
  DOM 处理依赖于 <a href="#View">Backbone.View</a> ,
    <a href="https://github.com/douglascrockford/JSON-js" target="_blank">json2.js</a>, 和
    <a href="http://jquery.com" target="_blank">jQuery</a> <small>( > 1.4.2)</small> 或
    <a href="http://zeptojs.com/" target="_blank">Zepto</a> 之一.
  </p>
  
  <h2 id="Introduction">简介</h2>
  
  <p>
  当我们开发含有大量Javascript的web应用程序时，首先你需要做的事情之一便是停止向DOM对象附加数据。
  通过复杂多变的jQuery选择符和回调函数创建Javascript应用程序，包括在HTML UI，Javascript逻辑和数据之间保持同步，都不复杂。
  但对富客户端应用来说，良好的架构通常是有很多益处的。
  </p>
  
  <p>
  Backbone将数据呈现为
    <a href="#Model">模型</a>, 你可以创建模型、对模型进行验证和销毁，甚至将它保存到服务器。
  当UI的变化引起模型属性改变时，模型会触发<i>"change"</i>事件；
  所有显示模型数据的 <a href="#View">视图</a> 会接收到该事件的通知，继而视图重新渲染。
  你无需查找DOM来搜索指定<i>id</i>的元素去手动更新HTML。
    &mdash; 当模型改变了，视图便会自动变化。
  </p>
  
  
  <h2 id="Events">Backbone.Events</h2>
  
  <p>
  <b>Events</b> 是一个可以被mix到任意对象的模块，它拥有让对象绑定和触发自定义事件的能力。
  事件在被绑定之前是不需要事先声明的，还可以携带参数。我们通过一个例子来看：
  </p>
  
<pre class="runnable">
var object = {};

_.extend(object, Backbone.Events);

object.bind("alert", function(msg) {
  alert("Triggered " + msg);
});

object.trigger("alert", "www.csser.com");
</pre>

  <p id="Events-bind">
    <b class="header">bind</b><code>object.bind(event, callback, [context])</code>
    <br />
    绑定 <b>callback</b> 函数到 object 对象。
  当<b>事件</b>触发时执行回调函数 callback 。如果一个页面中有大量不同的事件，按照惯例使用冒号指定命名空间：
     <tt>"poll:start"</tt>, 或 <tt>"change:selection"</tt>
  </p>
  
  <p>
  当 callback 执行时提供第三个可选参数，可以为 <tt>this</tt> 指定上下文： <tt>model.bind('change', this.render, this)</tt>
  </p>
  
  <p>
  绑定到特殊事件 <tt>"all"</tt> 的回调函数会在任意事件发生时被触发，其第一个参数为事件的名称。
  例如，将一个对象的所有事件代理到另一对象：
  </p>
  
<pre>
proxy.bind("all", function(eventName) {
  object.trigger(eventName);
});
</pre>

  <p id="Events-unbind">
    <b class="header">unbind</b><code>object.unbind([event], [callback])</code>
    <br />
  从 object 对象移除先前绑定的 <b>callback</b> 函数。如果不指定第二个参数，所有 <b>event</b> 事件绑定的回调函数都被移除。
  如果第一个参数也不指定，对象所绑定的<i>所有</i>回调函数都将被移除。
  </p>
  
<pre>
object.unbind("change", onChange);  // 只移除onChange回调函数

object.unbind("change");            // 移除所有 "change" 回调函数

object.unbind();                    // 移除对象的所有回调函数
</pre>

  <p id="Events-trigger">
    <b class="header">trigger</b><code>object.trigger(event, [*args])</code>
    <br />
  触发 <b>event</b> 事件的回调函数。后续传入 <b>trigger</b> 的参数会被依次传入事件回调函数。
  </p>
  
  <h2 id="Model">Backbone.Model</h2>
  
  <p>
  <b>模型</b> 是所有 Javascript 应用程序的核心，包括交互数据及相关的大量逻辑：
  转换、验证、计算属性和访问控制。你可以用特定的方法扩展 <b>Backbone.Model</b> ，
  <b>模型</b> 也提供了一组基本的管理变化的功能。
  </p>
  
  <p>
  下面的示例演示了如何定义一个模型，包括自定义方法、设置属性、以及触发该属性变化的事件。
  </p>
  
<pre class="runnable">
var Sidebar = Backbone.Model.extend({
  promptColor: function() {
  var cssColor = prompt("请输入一个CSS颜色值：");
  this.set({color: cssColor});
  }
});

window.sidebar = new Sidebar;

sidebar.bind('change:color', function(model, color) {
  $('#sidebar').css({background: color});
});

sidebar.set({color: 'white'});

sidebar.promptColor();
</pre>

  <p id="Model-extend">
    <b class="header">extend</b><code>Backbone.Model.extend(properties, [classProperties])</code>
    <br />
  要创建自己的 <b>模型</b> 类，你可以扩展 <b>Backbone.Model</b> 并提供实例 <b>属性</b> ，
  以及可选的可以直接注册到构造函数的 <b>类属性</b> (classProperties)。
  </p>
  
  <p>
  <b>extend</b> 可以正确的设置原型链，因此通过 <b>extend</b> 创建的子类 (subclasses) 也可以被深度扩展。
  </p>
  
<pre>
var Note = Backbone.Model.extend({

  initialize: function() { ... },
  
  author: function() { ... },
  
  coordinates: function() { ... },
  
  allowedToEdit: function(account) {
  return true;
  }
  
});

var PrivateNote = Note.extend({

  allowedToEdit: function(account) {
  return account.owns(this);
  }
  
});
</pre>

  <p class="warning">
  <tt>父类</tt> 的简述：Javascript没有提供一种直接调用父类的方式，
  如果你要重载原型链中上层定义的同名函数，如 <tt>set</tt>，或 <tt>save</tt> ，
  并且你想调用父对象的实现，这时需要明确的调用它，类似这样：
  </p>
  
<pre>
var CSSercom = Backbone.Model.extend({
  set: function(attributes, options) {
  Backbone.Model.prototype.set.call(this, attributes, options);
  ...
  }
});
</pre>

  <p id="Model-constructor">
    <b class="header">constructor / initialize</b><code>new Model([attributes])</code>
    <br />
  当创建模型实例时，可以传入 <b>属性</b> 初始值，这些值会被 <a href="#Model-set">set</a> 到模型。
  如果定义了 <b>initialize</b> 函数，该函数会在模型创建后执行。
  </p>
  
<pre>
new Site({
  title: "CSSer, 关注web前后端技术",
  author: "一回"
});
</pre>

  <p id="Model-get">
    <b class="header">get</b><code>model.get(attribute)</code>
    <br />
  从模型获取当前属性值，比如：<tt>csser.get("title")</tt>
  </p>
  
  <p id="Model-set">
    <b class="header">set</b><code>model.set(attributes, [options])</code>
    <br />
  向模型设置一个或多个散列属性。
  如果任何一个属性改变了模型的状态，在不传入 <tt>{silent: true}</tt> 选项参数的情况下，会触发 <tt>"change"</tt> 事件。
  可以绑定事件到某个属性，例如：<tt>change:title</tt>，及 <tt>change:content</tt>。
  </p>
  
<pre>
csser.set({title: "CSSer", content: "http://www.csser.com"});
</pre>

  <p>
  如果模型拥有 <a href="#Model-validate">validate</a> 方法，
  那么属性验证会在 set 之前执行，如果验证失败，模型不会发生变化，这时 <b>set</b> 会返回 <tt>false</tt>。
  也可以在选项中传入 <tt>error</tt> 回调函数，此时验证失败时会执行它而不触发 <tt>"error"</tt> 事件。
  </p>
  
  <p id="Model-escape">
    <b class="header">escape</b><code>model.escape(attribute)</code>
    <br />
  与 <a href="#Model-get">get</a> 类似, 但返回模型属性值的 HTML 转义后的版本。
  如果将数据从模型插入 HTML，使用 <b>escape</b> 取数据可以避免
    <a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank">XSS</a> 攻击.
  </p>
  
<pre class="runnable">
var hacker = new Backbone.Model({
  name: "&lt;script&gt;alert('xss')&lt;/script&gt;"
});

alert(hacker.escape('name'));
</pre>

  <p id="Model-has">
    <b class="header">has</b><code>model.has(attribute)</code>
    <br />
  属性值为非 null 或非 undefined 时返回 <tt>true</tt>
  </p>
  
<pre>
if (note.has("title")) {
  ...
}
</pre>

  <p id="Model-unset">
    <b class="header">unset</b><code>model.unset(attribute, [options])</code>
    <br />
  从内部属性散列表中删除指定属性。
  如果未设置 <tt>silent</tt> 选项，会触发 <tt>"change"</tt> 事件。
  </p>
  
  <p id="Model-clear">
    <b class="header">clear</b><code>model.clear([options])</code>
    <br />
  从模型中删除所有属性。
  如果未设置 <tt>silent</tt> 选项，会触发 <tt>"change"</tt> 事件。
  </p>
  
  <p id="Model-id">
    <b class="header">id</b><code>model.id</code>
    <br />
  模型的特殊属性， <b>id</b> 可以是任意字符串（整型 id 或 UUID）。
  在属性中设置的 <b>id</b> 会被直接拷贝到模型属性上。
  我们可以从集合（collections）中通过 id 获取模型，另外 id 通常用于生成模型的 URLs。
  </p>
  
  <p id="Model-cid">
    <b class="header">cid</b><code>model.cid</code>
    <br />
  模型的特殊属性，<b>cid</b> 或客户 id 是当所有模型创建时自动产生的唯一标识符。
  客户 ids 在模型尚未保存到服务器之前便存在，此时模型可能仍不具有最终的 <b>id</b>，
  客户 ids 的形式为：<tt>c1, c2, c3 ...</tt>
  </p>
  
  <p id="Model-attributes">
    <b class="header">attributes</b><code>model.attributes</code>
    <br />
  <b>attributes</b> 属性是包含模型状态的内部散列表。
  建议采用 <a href="#Model-set">set</a> 更新属性而不要直接修改。
  如要获取模型属性的副本，
    用 <a href="#Model-toJSON">toJSON</a> 取而代之。
  </p>
  
  <p id="Model-defaults">
    <b class="header">defaults</b><code>model.defaults or model.defaults()</code>
    <br />
  <b>defaults</b> 散列（或函数）用于为模型指定默认属性。
  创建模型实例时，任何未指定的属性会被设置为其默认值。
  </p>
  
<pre class="runnable">
var Meal = Backbone.Model.extend({
  defaults: {
  "appetizer":  "caesar salad",
  "entree":     "ravioli",
  "dessert":    "cheesecake"
  }
});

alert("Dessert will be " + (new Meal).get('dessert'));
</pre>

  <p class="warning">
  需要提醒的是，在 Javascript 中，对象是按引用传值的，因此包含对象作为默认值，它会被所有实例共享。
  </p>
  
  <p id="Model-toJSON">
    <b class="header">toJSON</b><code>model.toJSON()</code>
    <br />
  返回模型 <a href="#Model-attributes">attributes</a> 副本的 JSON 字符串化形式。
  它可用于模型的持久化、序列化，或者传递到视图前的扩充。
  该方法的名称有点混乱，因为它事实上并不返回 JSON 字符串，但
    <a href="https://developer.mozilla.org/en/JSON#toJSON()_method" target="_blank">JavaScript API for <b>JSON.stringify</b> </a>可以实现。
  </>
  
<pre class="runnable">
var artist = new Backbone.Model({
  firstName: "立华",
  lastName: "咸"
});

artist.set({birthday: "December 13, 1979"});

alert(JSON.stringify(artist));
</pre>

  <p id="Model-fetch">
    <b class="header">fetch</b><code>model.fetch([options])</code>
    <br />
  从服务器重置模型状态。这对模型尚未填充数据，或者服务器端已有最新状态的情况很有用处。
  如果服务器端状态与当前属性不同，则触发 <tt>"change"</tt> 事件。
  选项的散列表参数接受 <tt>success</tt> 和 <tt>error</tt> 回调函数，
  回调函数中可以传入 <tt>(model,response)</tt> 作为参数。
  </p>
  
<pre>
// 每隔 10 秒从服务器拉取数据以保持频道模型是最新的
setInterval(function() {
  channel.fetch();
}, 10000);
</pre>

  <p id="Model-save">
    <b class="header">save</b><code>model.save([attributes], [options])</code>
    <br />
  通过委托 <a href="#Sync">Backbone.sync</a> 保存模型到数据库（或可替代的持久层）。
  <b>attributes</b> 散列表
    (在 <a href="#Model-set">set</a>) 应当包含想要改变的属性，不涉及的键不会被修改。
    如果模型含有 <a href="#Model-validate">validate</a> 方法，并且验证失败，模型不会保存。
  如果模型
    <a href="#Model-isNew">isNew</a>, 保存将采用 <tt>"create"</tt>
    (HTTP <tt>POST</tt>) 方法, 如果模型已经在服务器存在，保存将采用
    <tt>"update"</tt> (HTTP <tt>PUT</tt>) 方法.
  </p>
  
  <p>
  在下面的示例，注意我们是如何在模型初次保存时接收到 <tt>"create"</tt> 请求，第二次接收到 <tt>"update"</tt>
  请求的。
  </p>
  
<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + JSON.stringify(model));
  model.id = 1;
};

var book = new Backbone.Model({
  title: "The Rough Riders",
  author: "Theodore Roosevelt"
});

book.save();

book.save({author: "Teddy"});
</pre>

  <p>
    <b>save</b> 支持在选项散列表中传入 <tt>success</tt> 和 <tt>error</tt> 回调函数，
    回调函数支持传入 <tt>(model, response)</tt> 作为参数。
  如果模型拥有 <tt>validate</tt> 方法并且验证失败，<tt>error</tt> 回调函数会执行。
  如果服务端验证失败，返回非 <tt>200</tt> 的 HTTP 响应码，将产生文本或 JSON 的错误内容。
  </p>
  
<pre>
book.save({author: "F.D.R."}, {error: function(){ ... }});
</pre>

  <p id="Model-destroy">
    <b class="header">destroy</b><code>model.destroy([options])</code>
    <br />
  通过委托 HTTP <tt>DELETE</tt> 请求到
    <a href="#Sync">Backbone.sync</a> 销毁服务器上的模型. 接受
    <tt>success</tt> 和 <tt>error</tt> 回调函数作为选项散列表参数。
  将在模型上触发 <tt>"destroy"</tt> 事件，该事件可以通过任意包含它的集合向上冒泡。
  </p>
  
<pre>
book.destroy({success: function(model, response) {
  ...
}});
</pre>

  <p id="Model-validate">
    <b class="header">validate</b><code>model.validate(attributes)</code>
    <br />
  该方法是未定义的，如果有在Javascript执行的需要，建议用自定义的验证逻辑重载它。
  <b>validate</b> 会在 <tt>set</tt> 和 <tt>save</tt> 之前调用，并传入待更新的属性。
  如果模型和属性通过验证，不返回任何值；
  如果属性不合法，返回一个可选择的错误。该错误可以是简单的用于显示的字符串错误信息，
  或者是一个可以描述错误详细的 error 对象。
  如果 <b>validate</b> 返回错误，<tt>set</tt> 和 <tt>save</tt> 将不会执行。
  失败的验证会触发一个 <tt>"error"</tt>事件。
  </p>
  
<pre class="runnable">
var Chapter = Backbone.Model.extend({
  validate: function(attrs) {
  if (attrs.end < attrs.start) {
    return "can't end before it starts";
  }
  }
});

var one = new Chapter({
  title : "Chapter One: The Beginning"
});

one.bind("error", function(model, error) {
  alert(model.get("title") + " " + error);
});

one.set({
  start: 15,
  end:   10
});
</pre>

  <p>
  <tt>"error"</tt> 事件对模型和集合级别提供粗粒度的错误信息很有帮助，
  但如果想设计更好的处理错误的特定视图，可以直接传入 <tt>error</tt> 回调函数重载事件。
  </p>
  
<pre>
account.set({access: "unlimited"}, {
  error: function(model, error) {
  alert(error);
  }
});
</pre>

  <p id="Model-url">
    <b class="header">url</b><code>model.url()</code>
    <br />
  返回模型资源在服务器上位置的相对 URL 。
  如果模型放在其它地方，可通过合理的逻辑重载该方法。
  生成 URLs 的形式为：<tt>"/[collection.url]/[id]"</tt>，
  如果模型不是集合的一部分，则 URLs 形式为：<tt>"/[urlRoot]/id"</tt>。
  </p>
  
  <p>
    由于是委托到 <a href="#Collection-url">Collection#url</a> 来生成 URL，
  所以首先需要确认它是否定义过，或者所有模型共享一个通用根 URL 时，是否存在 <a href="#Model-urlRoot">urlRoot</a> 属性。
  例如，一个 id 为 <tt>101</tt> 的模型，存储在
  <tt>url</tt> 为 <tt>"/documents/7/notes"</tt> 的 <a href="#Collection">Backbone.Collection</a> 中，
  那么该模型的 URL 为：<tt>"/documents/7/notes/101"</tt>
  </p>
  
  <p id="Model-urlRoot">
    <b class="header">urlRoot</b><code>model.urlRoot</code>
    <br />
  如果使用的集合外部的模型，通过指定 <tt>urlRoot</tt> 来设置生成基于模型 id 的 URLs 的默认 <a href="#Model-url">url</a> 函数。
  <tt>"/[urlRoot]/id"</tt>
  </p>
  
<pre class="runnable">
var Book = Backbone.Model.extend({urlRoot : '/books'});

var solaris = new Book({id: "1083-lem-solaris"});

alert(solaris.url());
</pre>

  <p id="Model-parse">
    <b class="header">parse</b><code>model.parse(response)</code>
    <br />
  <b>parse</b> 会在通过 <a href="#Model-fetch">fetch</a> 从服务器返回模型数据，以及 <a href="#Model-save">save</a> 时执行。
  传入本函数的为原始 <tt>response</tt> 对象，并且应当返回可以 <a href="#Model-set">set</a> 到模型的属性散列表。
  默认实现是自动进行的，仅简单传入 JSON 响应。
  如果需要使用已存在的 API，或者更好的命名空间响应，可以重载它。
  </p>
  
  <p>
  如果使用的 Rails 后端，需要注意 Rails's 默认的 <tt>to_json</tt> 实现已经包含了命名空间之下的模型属性。
  对于无缝的后端集成环境禁用这种行为：
  </p>
  
<pre>
ActiveRecord::Base.include_root_in_json = false
</pre>

  <p id="Model-clone">
    <b class="header">clone</b><code>model.clone()</code>
    <br />
  返回与模型属性一致的新的实例。
  </p>
  
  <p id="Model-isNew">
    <b class="header">isNew</b><code>model.isNew()</code>
    <br />
  模型是否已经保存到服务器。
  如果模型尚无 <tt>id</tt>，则被视为新的。
  </p>
  
  <p id="Model-change">
    <b class="header">change</b><code>model.change()</code>
    <br />
  手动触发 <tt>"change"</tt> 事件。
  如果已经在 <a href="#Model-set">set</a> 函数传入选项参数 <tt>{silent: true}</tt> ，
  当所有操作结束时，可以手动调用 <tt>model.change()</tt> 。
  </p>
  
  <p id="Model-hasChanged">
    <b class="header">hasChanged</b><code>model.hasChanged([attribute])</code>
    <br />
  标识模型从上次 <tt>"change"</tt> 事件发生后是否改变过。
  如果传入 <b>attribute</b> ，当指定属性改变后返回 <tt>true</tt>。
  </p>
  
  <p class="warning">
  注意，本方法以及接下来 change 相关的方法，仅对 <tt>"change"</tt> 事件发生有效。
  </p>
  
<pre>
book.bind("change", function() {
  if (book.hasChanged("title")) {
  ...
  }
});
</pre>

  <p id="Model-changedAttributes">
    <b class="header">changedAttributes</b><code>model.changedAttributes([attributes])</code>
    <br />
  仅获取模型属性已改变的散列表。
  或者也可以传入外来的 <b>attributes</b> 散列，返回该散列与模型不同的属性。
  一般用于指出视图的哪个部分已被更新，或者确定哪些需要与服务器进行同步。
  </p>
  
  <p id="Model-previous">
    <b class="header">previous</b><code>model.previous(attribute)</code>
    <br />
  在 <tt>"change"</tt> 事件发生的过程中，本方法可被用于获取已改变属性的旧值。
  </p>
  
<pre class="runnable">
var bill = new Backbone.Model({
  name: "二回"
});

bill.bind("change:name", function(model, name) {
  alert("名字已从 " + bill.previous("name") + " 改为 " + name);
});

bill.set({name : "一回"});
</pre>

  <p id="Model-previousAttributes">
    <b class="header">previousAttributes</b><code>model.previousAttributes()</code>
    <br />
  返回模型的上一个属性散列的副本。一般用于获取模型的不同版本之间的区别，或者当发生错误时回滚模型状态。
  </p>
  
  <h2 id="Collection">Backbone.Collection</h2>
  
  <p>集合是模型的有序组合，我们可以在集合上绑定 <tt>"change"</tt> 事件，从而当集合中的模型发生变化时获得通知，集合也可以监听 <tt>"add"</tt> 和 <tt>“remove"</tt> 事件， 从服务器更新，并能使用 <a href="#Collection-Underscore-Methods">Underscore.js  提供的方法</a> </p>
  
  <p>集合中的模型触发的任何事件都可以在集合身上直接触发，所以我们可以监听集合中模型的变化：<tt>Documents.bind("change:selected", ...)</tt></p>
  
  <p id="Collection-extend">
    <b class="header">extend</b><code>Backbone.Collection.extend(properties, [classProperties])</code>
    <br />
  通过扩展 <b>Backbone.Collection</b> 创建一个 <b>Collection</b> 类。实例属性参数 <b>properties</b> 以及 类属性参数 <b>classProperties</b> 会被直接注册到集合的构造函数。
  </p>
  
  <p id="Collection-model">
    <b class="header">model</b><code>collection.model</code>
    <br />
  指定集合的模型类。可以传入原始属性对象（和数组）来 <a href="#Collection-add">add</a>，<a href="#Collection-create">create</a>，以及
  <a href="#Collection-reset">reset</a>，传入的属性会被自动转换为适合的模型类型。
  </p>
  
<pre>
var Library = Backbone.Collection.extend({
  model: Book
});
</pre>

  <p id="Collection-constructor">
    <b class="header">constructor / initialize</b><code>new Collection([models], [options])</code>
    <br />
  当创建集合时，你可以选择传入初始的 <b>模型</b> 数组。集合的 <a href="#Collection-comparator">comparator</a> 函数也可以作为选项传入。
  如果定义了 <b>initialize</b> 函数，会在集合创建时被调用。
  </p>
  
<pre>
var tabs = new TabSet([tab1, tab2, tab3]);
</pre>

  <p id="Collection-models">
    <b class="header">models</b><code>collection.models</code>
    <br />
  访问集合中模型的原始值。通常我们使用 <tt>get</tt>，<tt>at</tt>，或 <b>Underscore方法</b> 访问模型对象，但偶尔也需要直接访问。
  </p>
  
  <p id="Collection-toJSON">
    <b class="header">toJSON</b><code>collection.toJSON()</code>
    <br />
  返回集合中包含的每个模型对象的数组。可用于集合的序列化和持久化。本方法名称容易引起混淆，因为它与
    <a href="https://developer.mozilla.org/en/JSON#toJSON()_method" target="_blank">JavaScript's JSON API</a> 命名相同.
  </p>
  
<pre class="runnable">
var collection = new Backbone.Collection([
  {name: "Tim", age: 5},
  {name: "Ida", age: 26},
  {name: "Rob", age: 55}
]);

alert(JSON.stringify(collection));
</pre>

  <p id="Collection-Underscore-Methods">
    <b class="header">Underscore 方法 (26)</b>
    <br />
  Backbone 代理了 <b>Underscore.js</b> 从而为 <b>Backbone.Collection</b> 提供了26个迭代函数。这里没有列出这些函数的使用方法，你可以点击链接前往查看：
  </p>
  
  <ul>
    <li><a href="http://documentcloud.github.com/underscore/#each" target="_blank">forEach (each)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#map" target="_blank">map</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#reduce" target="_blank">reduce (foldl, inject)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#reduceRight" target="_blank">reduceRight (foldr)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#detect" target="_blank">find (detect)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#select" target="_blank">filter (select)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#reject" target="_blank">reject</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#all" target="_blank">every (all)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#any" target="_blank">some (any)</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#include" target="_blank">include</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#invoke" target="_blank">invoke</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#max" target="_blank">max</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#min" target="_blank">min</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#sortBy" target="_blank">sortBy</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#groupBy" target="_blank">groupBy</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#sortedIndex" target="_blank">sortedIndex</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#toArray" target="_blank">toArray</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#size" target="_blank">size</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#first" target="_blank">first</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#rest" target="_blank">rest</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#last" target="_blank">last</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#without" target="_blank">without</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#indexOf" target="_blank">indexOf</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#lastIndexOf" target="_blank">lastIndexOf</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#isEmpty" target="_blank">isEmpty</a></li>
    <li><a href="http://documentcloud.github.com/underscore/#chain" target="_blank">chain</a></li>
  </ul>
  
<pre>
Books.each(function(book) {
  book.publish();
});

var titles = Books.map(function(book) {
  return book.get("title");
});

var publishedBooks = Books.filter(function(book) {
  return book.get("published") === true;
});

var alphabetical = Books.sortBy(function(book) {
  return book.author.get("name").toLowerCase();
});
</pre>

  <p id="Collection-add">
    <b class="header">add</b><code>collection.add(models, [options])</code>
    <br />
  向集合中增加模型（或模型数组）。默认会触发 <tt>"add"</tt> 事件，可以传入 <tt>{silent : true}</tt> 关闭。
  如果定义了 <a href="#Collection-model">模型</a> 属性，也可以传入原始的属性对象让其看起来像一个模型实例。
  传入 <tt>{at: index}</tt> 可以将模型插入集合中特定的位置。
  </p>
  
<pre class="runnable">
var ships = new Backbone.Collection;

ships.bind("add", function(ship) {
  alert("Ahoy " + ship.get("name") + "!");
});

ships.add([
  {name: "Flying Dutchman"},
  {name: "Black Pearl"}
]);
</pre>

  <p id="Collection-remove">
    <b class="header">remove</b><code>collection.remove(models, [options])</code>
    <br />
  从集合中删除模型（或模型数组）。会触发 <tt>"remove"</tt> 事件，同样可以使用 <tt>silent</tt> 关闭。
  </p>
  
  <p id="Collection-get">
    <b class="header">get</b><code>collection.get(id)</code>
    <br />
  返回集合中 id 为 <b>id</b> 的模型。
  </p>
  
<pre>
var book = Library.get(110);
</pre>

  <p id="Collection-getByCid">
    <b class="header">getByCid</b><code>collection.getByCid(cid)</code>
    <br />
  通过指定客户id返回集合中的模型。客户id是指模型创建时自动生成的 <tt>.cid</tt> 属性。在模型尚未保存到服务器时其还没有id值，所以通过cid获取模型很有用处。
  </p>
  
  <p id="Collection-at">
    <b class="header">at</b><code>collection.at(index)</code>
    <br />
  返回集合中指定索引的模型对象。不论你是否对模型进行了重新排序， <b>at</b> 始终返回其在集合中插入时的索引值。
  </p>
  
  <p id="Collection-length">
    <b class="header">length</b><code>collection.length</code>
    <br />
  与数组类似，集合拥有 <tt>length</tt> 属性，返回该集合拥有的模型数量。
  </p>
  
  <p id="Collection-comparator">
    <b class="header">comparator</b><code>collection.comparator</code>
    <br />
  默认情况下，集合没有声明 <b>comparator</b> 函数。如果定义了该函数，集合中的模型会按照指定的算法进行排序。
  换言之，模型被增加的同时会插入适合的位置。Comparator接收模型作为参数，返回数值或字符串作为相对其它模型的排序依据。
  </p>
  
  <p>
  注意即使下面例子中的章节是后加入集合中的，但它们都会遵循正确的排序：
  </p>
  
<pre class="runnable">
var Chapter  = Backbone.Model;
var chapters = new Backbone.Collection;

chapters.comparator = function(chapter) {
  return chapter.get("page");
};

chapters.add(new Chapter({page: 9, title: "The End"}));
chapters.add(new Chapter({page: 5, title: "The www.csser.com"}));
chapters.add(new Chapter({page: 1, title: "The Beginning"}));

alert(chapters.pluck('title'));
</pre>

  <p class="warning">
  说明：comparator 函数与 Javascript 的 "sort" 并不相同，后者必须返回 <tt>0</tt>, <tt>1</tt>, 或 <tt>-1</tt>, 前者则更像 <tt>sortBy</tt> &mdash; 一个更友好的API。
  </p>
  
  <p id="Collection-sort">
    <b class="header">sort</b><code>collection.sort([options])</code>
    <br />
  强制对集合进行重排序。一般情况下不需要调用本函数，因为 <a href="#Collection-comparator">comparator</a> 函数会实时排序。
  如果不指定 <tt>{silent: true}</tt> ，调用 <b>sort</b> 会触发集合的 <tt>"reset"</tt> 事件。
  </p>
  
  <p id="Collection-pluck">
    <b class="header">pluck</b><code>collection.pluck(attribute)</code>
    <br />
  从集合中的每个模型拉取 <tt>attribute</tt>。等价于调用 <tt>map</tt>，并从迭代器中返回单个属性。
  </p>
  
<pre class="runnable">
var stooges = new Backbone.Collection([
  new Backbone.Model({name: "Curly"}),
  new Backbone.Model({name: "Larry"}),
  new Backbone.Model({name: "Moe"})
]);

var names = stooges.pluck("name");

alert(JSON.stringify(names));
</pre>

  <p id="Collection-url">
    <b class="header">url</b><code>collection.url or collection.url()</code>
    <br />
  设置 <b>url</b> 属性（或函数）以指定集合对应的服务器位置。集合内的模型使用 <b>url</b> 构造自身的 URLs。
  </p>
  
<pre>
var Notes = Backbone.Collection.extend({
  url: '/notes'
});

// 或者，更复杂一些的方式：

var Notes = Backbone.Collection.extend({
  url: function() {
  return this.document.url() + '/notes';
  }
});
</pre>

  <p id="Collection-parse">
    <b class="header">parse</b><code>collection.parse(response)</code>
    <br />
  每一次调用 <a href="#Collectionfetch">fetch</a> 从服务器拉取集合的模型数据时，<b>parse</b>都会被调用。
  本函数接收原始 <tt>response</tt> 对象，返回可以 <a href="#Collection-add">add</a> 到集合的模型属性数组。
  默认实现是无需操作的，只需简单传入服务端返回的JSON对象。
  如果需要处理遗留API，或者在返回数据定义自己的命名空间，可以重写本函数。
  </p>
  
<pre>
var Tweets = Backbone.Collection.extend({
  // Twitter 搜索 API 在 "result" 键下返回 tweets
  parse: function(response) {
  return response.results;
  }
});
</pre>

  <p id="Collection-fetch">
    <b class="header">fetch</b><code>collection.fetch([options])</code>
    <br />
  从服务器拉取集合的默认模型，成功接收数据后会重置（reset）集合。
  <b>options</b> 支持 <tt>success</tt> 和 <tt>error</tt> 回调函数，回调函数接收 <tt>(collection, response)</tt> 作为参数。
  可以委托 <a href="#Sync">Backbone.sync</a> 在随后处理个性化需求。
  处理 <b>fetch</b> 请求的服务器应当返回模型的 <tt>JSON</tt> 数组。
  </p>
  
<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + model.url);
};

var Accounts = new Backbone.Collection;
Accounts.url = '/accounts';

Accounts.fetch();
</pre>

  <p>
  如果希望向当前集合追加模型数据而不是替换，传入 <tt>{add: true}</tt> 作为 <b>fetch</b> 的参数。
  </p>
  
  <p>
  <b>fetch</b> 的参数可以支持直接传入 <b>jQuery.ajax</b> 作为参数，所以拉取指定页码的集合数据可以这样写：。
    <tt>Documents.fetch({data: {page: 3}})</tt>
  </p>
  
  <p>
  不建议在页面加载完毕时利用 <b>fetch</b> 拉取并填充集合数据 &mdash; 所有页面初始数据应当在 <a href="#FAQ-bootstrap">bootstrapped</a> 时已经就绪。
  <b>fetch</b> 适用于惰性加载不需立刻展现的模型数据。
  </p>
  
  <p id="Collection-reset">
    <b class="header">reset</b><code>collection.reset(models, [options])</code>
    <br />
  每次一个的向集合做增删操作已经很好了，但有时会有很多的模型变化以至于需要对集合做大批量的更新操作。
  利用 <b>reset</b> 可将集合替换为新的模型（或键值对象），结束后触发 <tt>"reset"</tt> 事件。
  传入 <tt>{silent: true}</tt> 忽略 <tt>"reset"</tt> 事件的触发。
  不传入任何参数将清空整个集合。
  </p>
  
  <p>
  这里有一个在页面加载完毕后 <b>reset</b> 初始启动集合的例子：
  </p>
  
<pre>
&lt;script&gt;
  Accounts.reset(&lt;%= @csser.to_json %&gt;);
&lt;/script&gt;
</pre>


  <p id="Collection-create">
    <b class="header">create</b><code>collection.create(attributes, [options])</code>
    <br />
  在集合中创建一个模型。
  等价于用键值对象实例一个模型，然后将模型保存到服务器，保存成功后将模型增加到集合中。
  如果验证失败会阻止模型创建，返回 <tt>false</tt>，否则返回该模型。
  为了能正常运行，需要在集合中设置 <a href="#Collection-model">model</a> 属性。
  <b>create</b> 方法接收键值对象或者已经存在尚未保存的模型对象作为参数。
  </p>
  
<pre>
var Library = Backbone.Collection.extend({
  model: Book
});

var NYPL = new Library;

var othello = NYPL.create({
  title: "Backbone.js API 中文手册",
  author: "一回（www.csser.com）"
});
</pre>

  <h2 id="Router">Backbone.Router</h2>
  
  <p>
   web应用程序通常需要为应用的重要位置提供可链接，可收藏，可分享的 URLs。
   直到最近， 锚点（hash）片段（<tt>#page</tt>）可以被用来提供这种链接，
   同时随着 History API 的到来，锚点已经可以用于处理标准 URLs （<tt>/page</tt>）。
   <b>Backbone.Router</b> 为客户端路由提供了许多方法，并能连接到指定的动作（actions）和事件（events）。
   对于不支持 History API 的旧浏览器，路由提供了优雅的回调函数并可以透明的进行 URL 片段的转换。
  </p>
  
  <p>
  页面加载期间，当应用已经创建了所有的路由，需要调用 <tt>Backbone.history.start()</tt>，或 <tt>Backbone.history.start({pushState : true})</tt> 来确保驱动初始化 URL 的路由。
  </p>
  
  <p id="Router-extend">
    <b class="header">extend</b><code>Backbone.Router.extend(properties, [classProperties])</code>
    <br />
  创建一个自定义的路由类。
  可以通过 <a href="#Router-routes">routes</a> 定义路由动作键值对，当匹配了 URL 片段便执行定义的动作。
  </p>
  
<pre>
var Workspace = Backbone.Router.extend({

  routes: {
  "help":                 "help",    // #help
  "search/:query":        "search",  // #search/kiwis
  "search/:query/p:page": "search"   // #search/kiwis/p7
  },
  
  help: function() {
  ...
  },
  
  search: function(query, page) {
  ...
  }
  
});
</pre>

  <p id="Router-routes">
    <b class="header">routes</b><code>router.routes</code>
    <br />
  routes 将带参数的 URLs 映射到路由实例的方法上，这与 <a href="#View">视图</a> 的 <a href="#View-delegateEvents">事件键值对</a> 非常类似。
  路由可以包含参数，<tt>:param</tt>，它在斜线之间匹配 URL 组件。
  路由也支持通配符，<tt>*splat</tt>，可以匹配多个 URL 组件。
  </p>
  
  <p>
  举个例子，路由 <tt>"search/:query/p:page"</tt> 能匹配 <tt>#search/obama/p2</tt> , 这里传入了 <tt>"obama"</tt> 和 <tt>"2"</tt> 到路由对应的动作中去了。
  <tt>"file/*path</tt> 路由可以匹配 <tt>#file/nested/folder/file.txt</tt>，这时传入动作的参数为 <tt>"nested/folder/file.txt"</tt>。
  </p>
  
  <p>
  当访问者点击浏览器后退按钮，或者输入 URL ，如果匹配一个路由，此时会触发一个基于动作名称的 <a href="#Events">事件</a>，
  其它对象可以监听这个路由并接收到通知。
  下面的示例中，用户访问 <tt>#help/uploading</tt> 将从路由中触发 <tt>route:help</tt> 事件。
  </p>
  
<pre>
routes: {
  "help/:page":         "help",
  "download/*path":     "download",
  "folder/:name":       "openFolder",
  "folder/:name-:mode": "openFolder"
}
</pre>

<pre>
router.bind("route:help", function(page) {
  ...
});
</pre>

  <p id="Router-constructor">
    <b class="header">constructor / initialize</b><code>new Router([options])</code>
    <br />
  实例化一个路由对象，你可以直接传入 <a href="#Router-routes">routes</a> 键值对象作为参数。
  如果定义该参数， 它们将被传入 <tt>initialize</tt> 构造函数中初始化。
  </p>
  
  <p id="Router-route">
    <b class="header">route</b><code>router.route(route, name, callback)</code>
    <br />
  为路由对象手动创建路由，<tt>route</tt> 参数可以是 <a href="#Router-routes">路由字符串</a> 或 正则表达式。
  每个捕捉到的被传入的路由或正则表达式，都将作为参数传入回调函数（callback）。
  一旦路由匹配，<tt>name</tt> 参数会触发 <tt>"route:name"</tt> 事件。
  </p>
  
<pre>
initialize: function(options) {

  // 匹配 #page/10, 传入回调函数 "10"
  this.route("page/:number", "page", function(number){ ... });
  
  // 匹配 /csser.com/b/c/open, 传入回调函数 "csser.com/b/c"
  this.route(/^(.*?)/open$/, "open", function(id){ ... });
  
}
</pre>

  <p id="Router-navigate">
    <b class="header">navigate</b><code>router.navigate(fragment, [triggerRoute])</code>
    <br />
  手动到达应用程序中的某个位置。
  传入 <b>triggerRoute</b> 以执行路由动作函数。
  </p>
  
<pre>
openPage: function(pageNumber) {
  this.document.pages.at(pageNumber).open();
  this.navigate("page/" + pageNumber);
}

# 或者 ...

app.navigate("help/troubleshooting", true);
</pre>

  <h2 id="History">Backbone.history</h2>
  
  <p>
  <b>History</b> 作为全局路由服务用于处理 <tt>hashchange</tt> 事件或 <tt>pushState</tt>，匹配适合的路由，并触发回调函数。
  我们不需要自己去做这些事情 &mdash; 如果使用带有键值对的 <a href="#Router">路由</a>，<tt>Backbone.history</tt> 会被自动创建。
  </p>
  
  <p>
  Backbone 会自动判断浏览器对 <b>pushState</b> 的支持，以做内部的选择。
  不支持 <tt>pushState</tt> 的浏览器将会继续使用基于锚点的 URL 片段，
  如果兼容 <tt>pushState</tt> 的浏览器访问了某个 URL 锚点，将会被透明的转换为真实的 URL。
  注意使用真实的 URLs 需要 web 服务器支持直接渲染那些页面，因此后端程序也需要做修改。
  例如，如果有这样一个路由 <tt>/document/100</tt>，如果浏览器直接访问它， web 服务器必须能够处理该页面。
  趋于对搜索引擎爬虫的兼容，让服务器完全为该页面生成静态 HTML 是非常好的做法 ...
  但是如果要做的是一个 web 应用，只需要利用 Javascript 和 Backbone 视图将服务器返回的 REST 数据渲染就很好了。
  </p>
  
  <p id="History-start">
    <b class="header">start</b><code>Backbone.history.start([options])</code>
    <br />
  当所有的 <a href="#Router">路由</a> 创建并设置完毕，调用 <tt>Backbone.history.start()</tt> 开始监控 <tt>hashchange</tt> 事件并分配路由。
  </p>
  
  <p>
  需要指出的是，如果想在应用中使用 HTML5 支持的 <tt>pushState</tt>，只需要这样做：<tt>Backbone.history.start({pushState : true})</tt> 。
  </p>
  
  <p>
  如果应用不是基于域名的根路径 <tt>/</tt>，需要告诉 History 基于什么路径：
    <tt>Backbone.history.start({pushState: true, root: "/public/search/"})</tt>
  </p>
  
  <p>
  当执行后，如果某个路由成功匹配当前 URL，<tt>Backbone.history.start()</tt> 返回 <tt>true</tt>。
  如果没有定义的路由匹配当前 URL，返回 <tt>false</tt>。
  </p>
  
  <p>
  如果服务器已经渲染了整个页面，但又不希望开始 History 时触发初始路由，传入 <tt>silent : true</tt> 即可。
  </p>
  
<pre>
$(function(){
  new WorkspaceRouter();
  new HelpPaneRouter();
  Backbone.history.start({pushState: true});
});
</pre>

  <h2 id="Sync">Backbone.sync</h2>
  
  <p>
  <b>Backbone.sync</b> 是 Backbone 每次向服务器读取或保存模型时都要调用执行的函数。
  默认情况下，它使用 <tt>(jQuery/Zepto).ajax</tt> 方法发送 RESTful json 请求。
  如果想采用不同的持久化方案，比如 WebSockets, XML, 或 Local Storage，我们可以重载该函数。
  </p>
  
  <p>
  <b>Backbone.sync</b> 的语法为 <tt>sync(method, model, [options])</tt>。
  </p>
  
  <ul>
    <li><b>method</b> – CRUD 方法 (<tt>"create"</tt>, <tt>"read"</tt>, <tt>"update"</tt>, 或 <tt>"delete"</tt>)</li>
    <li><b>model</b> – 要被保存的模型（或要被读取的集合）</li>
    <li><b>options</b> – 成功和失败的回调函数，以及所有 jQuery 请求支持的选项</li>
  </ul>
  
  <p>
  默认情况下，当 <b>Backbone.sync</b> 发送请求以保存模型时，其属性会被序列化为 JSON，并以 <tt>application/json</tt> 的内容类型发送。
  当接收到来自服务器的 JSON 响应后，对经过服务器改变的模型进行拆解，然后在客户端更新。
  当 <tt>"read"</tt> 请求从服务器端响应一个集合（<a href="#Collection#fetch">Collection#fetch</a>）时，便拆解模型属性对象的数组。
  </p>
  
  <p>
  默认 <b>sync</b> 映射 REST 风格的 CRUD 类似下面这样：
  </p>
  
  <ul>
    <li><b>create &rarr; POST &nbsp; </b><tt>/collection</tt></li>
    <li><b>read &rarr; GET &nbsp; </b><tt>/collection[/id]</tt></li>
    <li><b>update &rarr; PUT &nbsp; </b><tt>/collection/id</tt></li>
    <li><b>delete &rarr; DELETE &nbsp; </b><tt>/collection/id</tt></li>
  </ul>
  
  
  <p id="Sync-emulateHTTP">
    <b class="header">emulateHTTP</b><code>Backbone.emulateHTTP = true</code>
    <br />
  老的浏览器不支持 Backbone 默认的 REST/HTTP，此时可以开启 <tt>Backbone.emulateHTTP</tt> 。
  设置该选项将通过 <tt>POST</tt> 方法伪造 <tt>PUT</tt> 和 <tt>DELETE</tt> 请求，此时该请求会向服务器传入名为 <tt>_method</tt> 的参数。
  设置该选项同时也会向服务器发送 <tt>X-HTTP-Method-Override</tt> 头。
  </p>
  
<pre>
Backbone.emulateHTTP = true;

model.save();  // POST 到 "/collection/id", 附带 "_method=PUT" + header.
</pre>

  <p id="Sync-emulateJSON">
    <b class="header">emulateJSON</b><code>Backbone.emulateJSON = true</code>
    <br />
  同样老的浏览器也不支持发送 <tt>application/json</tt> 编码的请求，
  设置 <tt>Backbone.emulateJSON = true;</tt> 后 JSON 模型会被序列化为 <tt>model</tt> 参数，
  请求会按照 <tt>application/x-www-form-urlencoded</tt> 的内容类型发送，就像提交表单一样。
  </p>
  
  <h2 id="View">Backbone.View</h2>
  
  <p>
  Backbone 视图的使用相当方便 &mdash; 它不会影响任何的 HTML 或 CSS 代码，并且可以与任意 Javascript 模板引擎兼容。
  基本的做法就是，将界面组织到逻辑视图，之后是模型，当模型数据发生改变，视图立刻自动更新，这一切都不需要重绘页面。
  我们再也不必钻进 JSON 对象中，查找 DOM 元素，手动更新 HTML 了，通过绑定视图的 <tt>render</tt> 函数到模型的 <tt>"change"</tt> 事件 &mdash; 模型数据会即时的显示在 UI 中。
  </p>
  
  <p id="View-extend">
    <b class="header">extend</b><code>Backbone.View.extend(properties, [classProperties])</code>
    <br />
  创建自定义的视图类。
  通常我们需要重载 <a href="#View-render">render</a> 函数，声明 <a href="#View-delegateEvents">事件</a>，
  以及通过 <tt>tagName</tt>，<tt>className</tt>，或 <tt>id</tt> 为视图指定根元素。
  </p>
  
<pre>
var DocumentRow = Backbone.View.extend({

  tagName: "li",
  
  className: "document-row",
  
  events: {
  "click .icon":          "open",
  "click .button.edit":   "openEditDialog",
  "click .button.delete": "destroy"
  },
  
  render: function() {
  ...
  }
  
});
</pre>

  <p id="View-constructor">
    <b class="header">constructor / initialize</b><code>new View([options])</code>
    <br />
  每次实例化一个视图时，传入的选项参数会被注册到 <tt>this.options</tt> 中以备后用。
  这里有多个特殊的选项，如果传入，则直接注册到视图中去：
    <tt>model</tt>, <tt>collection</tt>,
    <tt>el</tt>, <tt>id</tt>, <tt>className</tt>, 以及 <tt>tagName</tt>.
  如果视图定义了 <b>initialize</b> 函数，当视图实例化时该函数便立刻执行。
  如果希望创建一个指向 DOM 中已存在的元素的视图，传入该元素作为选项：
    <tt>new View({el: existingElement})</tt>
  </p>
  
<pre>
var doc = Documents.first();

new DocumentRow({
  model: doc,
  id: "document-row-" + doc.id
});
</pre>

  <p id="View-el">
    <b class="header">el</b><code>view.el</code>
    <br />
  所有的视图都拥有一个 DOM 元素（<b>el</b> 属性），即使该元素仍未插入页面中去。
  视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。
  <tt>this.el</tt> 可以从视图的 <tt>tagName</tt>，<tt>className</tt>，以及 <tt>id</tt> 属性创建，如果都未指定，<b>el</b> 会是一个空 <tt>div</tt>。
  </p>
  
  <p>
  如果希望将 <b>el</b> 赋给页面 DOM 中已经存在的元素，直接设置其值为真实的 DOM 元素或 CSS 选择符字符串。
  </p>
  
<pre class="runnable">
var ItemView = Backbone.View.extend({
  tagName: 'li'
});

var BodyView = Backbone.View.extend({
  el: 'body'
});

var item = new ItemView();
var body = new BodyView();

alert(item.el + ' ' + body.el);
</pre>

  <p id="View-dollar">
    <b class="header">$ (jQuery 或 Zepto)</b><code>view.$(selector)</code>
    <br />
  如果页面中引入了 jQuery 或 Zepto ，每个视图都将拥有 <b>$</b> 函数，可以在视图元素查询作用域内运行。
  如果使用该作用域内的 jQuery 函数，就不需要从列表中指定的元素获取模型的 ids 这种查询了，我们可以更多的依赖 HTML class 属性。
  它等价于运行：<tt>$(selector, this.el)</tt>。
  </p>
  
<pre>
ui.Chapter = Backbone.View.extend({
  serialize : function() {
  return {
    title: this.$(".title").text(),
    start: this.$(".start-page").text(),
    end:   this.$(".end-page").text()
  };
  }
});
</pre>

  <p id="View-render">
    <b class="header">render</b><code>view.render()</code>
    <br />
  <b>render</b> 默认实现是没有操作的。
  重载本函数可以实现从模型数据渲染视图模板，并可用新的 HTML 更新 <tt>this.el</tt>。
  推荐的做法是在 <b>render</b> 函数的末尾 <tt>return this</tt> 以开启链式调用。
  </p>
  
<pre>
var Bookmark = Backbone.View.extend({
  render: function() {
  $(this.el).html(this.template(this.model.toJSON()));
  return this;
  }
});
</pre>

  <p>
  Backbone 并不知道开发者使用何种模板引擎。
  <b>render</b> 函数中可以采用拼字符串，或者利用 <tt>document.createElement</tt> 创建 DOM 树等等。
  但还是建议选择一个好的 Javascript 模板引擎。
    <a href="http://github.com/janl/mustache.js" target="_blank">Mustache.js</a>,
    <a href="http://github.com/creationix/haml-js" target="_blank">Haml-js</a>, 以及
    <a href="http://github.com/sstephenson/eco" target="_blank">Eco</a> 都是很好的选择。
    因为 <a href="http://documentcloud.github.com/underscore/" target="_blank">Underscore.js</a> 已经引入页面了，
    所以为了防止 XSS 攻击带给数据的安全威胁，<a href="http://documentcloud.github.com/underscore/#template" target="_blank">_.template</a> 可以使用并是一个很好的选择。
  </p>
  
  <p>
  无论基于什么考虑，都永远不要在 Javascript 中拼接 HTML 字符串。
  </p>
  
  <p id="View-remove">
    <b class="header">remove</b><code>view.remove()</code>
    <br />
  从 DOM 中移除视图。它等价与下面的语句：
    <tt>$(view.el).remove();</tt>
  </p>
  
  <p id="View-make">
    <b class="header">make</b><code>view.make(tagName, [attributes], [content])</code>
    <br />
  借助给定的元素类型（<b>tagName</b>），以及可选的 attributes 和 HTML 内容创建 DOM 元素。
  通常用于内部创建初始的 <tt>view.el</tt>。
  </p>
  
<pre class="runnable">
var view = new Backbone.View;

var el = view.make("b", {className: "bold"}, "Bold! ");

$("#make-demo").append(el);
</pre>

<div id="make-demo"></div>

  <p id="View-delegateEvents">
    <b class="header">delegateEvents</b><code>delegateEvents([events])</code>
    <br />
  采用 jQuery 的<tt>delegate</tt> 函数来为视图内的 DOM 事件提供回调函数声明。
  如果未传入 <b>events</b> 对象，使用 <tt>this.events</tt> 作为事件源。
  事件对象的书写格式为 <tt>{"event selector" : "callback"}</tt>。
  省略 <tt>selector</tt> 则事件被绑定到视图的根元素（<tt>this.el</tt>）。
  默认情况下，<tt>delegateEvents</tt> 会在视图的构造函数内被调用，因此如果有 <tt>events</tt> 对象，所有的 DOM 事件已经被连接，
  并且我们永远不需要去手动调用本函数。
  </p>
  
  <p>
  <tt>events</tt> 属性也可以被定义成返回 <b>events</b> 对象的函数，这样让我们定义事件，以及实现事件的继承变得更加方便。
  </p>
  
  <p>
  视图 <a href="#View-render">渲染</a> 期间使用 <b>delegateEvents</b> 相比用 jQuery 向子元素绑定事件有更多优点。
  所有注册的函数在传递给 jQuery 之前已被绑定到视图上，因此当回调函数执行时，<tt>this</tt> 仍将指向视图对象。
  当 <b>delegateEvents</b> 再次运行，此时或许需要一个不同的 <tt>events</tt> 对象，所以所有回调函数将被移除，然后重新委托 &mdash;
  这对模型不同行为也不同的视图挺有用处。
  </p>
  
  <p>
  搜索结果页面显示文档的视图看起来类似这样：
  </p>
  
<pre>
var DocumentView = Backbone.View.extend({

  events: {
  "dblclick"                : "open",
  "click .icon.doc"         : "select",
  "contextmenu .icon.doc"   : "showMenu",
  "click .show_notes"       : "toggleNotes",
  "click .title .lock"      : "editAccessLevel",
  "mouseover .title .date"  : "showTooltip"
  },
  
  render: function() {
  $(this.el).html(this.template(this.model.toJSON()));
  return this;
  },
  
  open: function() {
  window.open(this.model.get("viewer_url"));
  },
  
  select: function() {
  this.model.set({selected: true});
  },
  
  ...
  
});
</pre>

  <h2 id="Utility">Utility Functions</h2>
  
  <p>
  
  </p>
  
  <p id="Utility-noConflict">
    <b class="header">noConflict</b><code>var backbone = Backbone.noConflict();</code>
    <br />
  返回 <tt>Backbone</tt> 对象的原始值。通常用于在第三方网站上引入了多个 Backbone 文件，避免冲突。
  </p>
  
<pre>
var localBackbone = Backbone.noConflict();
var model = localBackbone.Model.extend(...);
</pre>

</div></div><script>var MODULES = ['app/manual'];</script></div><div class="container"><a id="to-top" href="javascript:;">返回顶部</a><footer>&copy;2011-2012 csser.com</footer></div><script>;(function(m, o, d, u, l, a, r) {if(m[d]) return;function f(n, t) { return function() { r.push(n, arguments); return t; } }m[d] = a = { args: (r = []), config: f(0, a), use: f(1, a) };m.define = f(2);u = o.createElement('script');u.id = d + 'node';u.src = 'http://s0.csser.com/sea.js?v0.5.1-3';l = o.getElementsByTagName('head')[0];l.insertBefore(u, l.firstChild);})(window, document, 'seajs');seajs.use('init.js?v0.5.1-3');</script><script id="more-boards-template" type="text/template">{{#boards}}
<li>
 <div class="post{{#hasPost}} has-post{{/hasPost}}">
  <strong title="{{post_num}}贴">{{post_num}}</strong>
 </div>
 <div class="info">
  <h3><a href="/board/{{_id}}" title="{{title}}">{{title}}</a></h3>
  {{#posts}}{{#postTitle}}
  <h4>&#187; <a href="/board/{{pid}}#/post/{{postId}}" title="{{postTitle}}">{{postTitle}}</a></h4>
  {{/postTitle}}{{/posts}}
 </div>
 <div class="cmd">
  <a class="btn btn-mini btn-inverse do-follow" href="javascript:;" data-type="board" data-id="{{_id}}" data-cmd="{{#imfollower}}unfollow{{/imfollower}}{{^imfollower}}follow{{/imfollower}}">{{#imfollower}}取消关注{{/imfollower}}{{^imfollower}}关注{{/imfollower}}</a>
  <span class="badge badge-warning">{{follow_num}}</span>
 </div>
</li>
{{/boards}}</script><script id="review-item-template" type="text/template"><a href="/user/{{user.domain}}" class="photo" title="{{user.username}}">
 <img src="{{user.avatar}}" width="25" height="25" alt="{{user.username}}" />
</a>
<div class="info">
 <a href="/user/{{user.domain}}" title="{{user.username}}">{{user.username}}</a>
 <span class="date" data-time="{{dateTime}}">{{dateText}}</span>
 {{^my}}<a href="javascript:;" class="reply" data-form="#form-%-{{#answer}}{{answer}}{{/answer}}{{^answer}}{{post}}{{/answer}}" data-username="{{user.username}} ">回复</a>{{/my}}
 {{#my}}<a class="edit-review" href="javascript:;">修改评论</a>{{/my}}
 <div class="review-content">{{{review}}}</div>
 {{#my}}
 <form method="post" class="form" id="form-{{#answer}}qreview{{/answer}}{{^answer}}breview{{/answer}}-{{_id}}" action="/{{#answer}}qreview{{/answer}}{{^answer}}breview{{/answer}}">
  <input type="hidden" name="_id" value="{{_id}}">
  <div class="control-group">
   <div class="controls"><textarea class="edit-review textarea" name="review" id="review"></textarea></div>
  </div>
  <div class="form-actions">
   <input type="submit" name="dosubmit" value="保存评论" class="btn btn-primary">
   <a href="javascript:;" class="btn edit-cancel">取消</a>
  </div>
 </form>
 {{/my}}
</div>
</script><div class="form-follow"></div><div class="show-info"></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-94078-3']);
_gaq.push(['_trackPageview']);
(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></body></html>